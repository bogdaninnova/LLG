package main;

import java.util.*;

import painting.CreateGIF;
import painting.Draw;
import main.fields.Anisotrophia;
import main.fields.Circular;
import main.fields.Impuls;
import main.observers.EnergyCounter;

public class Launcher {
	
	public static void main(String...strings) {

		
		
		Calculator c = new Calculator();
		c.fieldsList.getFields().add(new Anisotrophia(0, 0));
		c.fieldsList.getFields().add(new Circular(0, 0));

		
		for (double tetta = 0; tetta < 1; tetta += 0.01) {
			((Anisotrophia) c.fieldsList.get(Anisotrophia.class)).
				setVector(new Vector(Math.PI * tetta, 0));
				
				
			for (double h = 0.02; h <= 0.4001; h += 0.01) {
				List<Double> list = new LinkedList<Double>();
				for (double w = 0.01; w <= 2.0001; w += 0.01) {
					System.out.println(w);
					((Circular) c.fieldsList.get(Circular.class)).setNewData(w, h);
					c.run(300);
					list.add(c.getObserverValue(EnergyCounter.class));
				}
				Writer.writeDoubleList(list, "Tetta = " + tetta + ", (h = " + h +")");
			}
		}
		
		
		/*
		
		Calculator c = new Calculator();
		c.fieldsList.getFields().add(new Anisotrophia(Math.PI * 0, 0));
		c.fieldsList.getFields().add(new Circular(0.96, 0.01));
		
		Date date = new Date();
		
		c.run(300);
		
		System.out.println(new Date().getTime() - date.getTime());
		
		new Draw(c, 0.4 * Math.PI, 0.4 * Math.PI, 0, "NAME").drawTraectory(true);	
		//new Draw(c, 0.4 * Math.PI, 0.4 * Math.PI, 0, "NAME").drawAnimationTraectory();;
		
		
		//CreateGIF.create("D:\\BohdanPedchenko\\eclipse-java-luna-SR1-win32\\workspace\\Strainge\\fig", "animation");
		


		/*
		Calculator c = new Calculator();
		c.fieldsList.getFields().add(new Anisotrophia(0, 0));
		
		
		double h = 0.5;
		double tao = 20;
		
		Impuls impuls = new Impuls(new Vector(1, 0, 0));
		//impuls.add(0, h, 0.01);
		impuls.add(h, h, tao);
		//impuls.add(h, 0, 0.01);
		c.fieldsList.getFields().add(impuls);
		
		c.setBeginningLocation(new Vector(Math.PI * 0, 0));
		c.run(0, 1000);
		new Draw(c, 0.4 * Math.PI, 0.4 * Math.PI, 0, "NAME").drawTraectory(true);
		//new Draw(c, 0.4 * Math.PI, 0.4 * Math.PI, 0, "NAME").drawAnimationTraectory();

		
		//drawCircularTrack(10, 1);
		
		//System.out.println(tetta / Math.PI);
		//System.out.println(c3.getObserverValue(EnergyCounter.class) * 100000);

		/*Calculator c2 = new Calculator();
		
		double h = 0.53;
		Impuls impuls = new Impuls(new Vector(1, 0, 0));
		impuls.add(0, 0, 10);
		impuls.add(0, h, 0.01);
		impuls.add(h, h, 50);
		impuls.add(h, 0, 0.01);
		
		//c2.fieldsList.getFields().add(impuls);
		//c2.fieldsList.getFields().add(new Circular(0.5, 1));
		c2.fieldsList.getFields().add(new Anisotrophia(0, 0));
		
		
		c2.run(0, 100);
		DrawComponents.draw(c2);*/
		//new Draw(c2, Math.PI / 2 + Math.PI / 8,Math.PI / 8,0, "hope").drawTraectory();

	}
	
	
	public static void drawCircularTrack(double h, double w) {
		Calculator c = new Calculator();
		c.fieldsList.getFields().add(new Anisotrophia(0, 0));
		c.fieldsList.getFields().add(new Circular(w, h));
		
		c.run(200, 20);
				
		new Draw(c, 0.4 * Math.PI, 0.4 * Math.PI, 0, Double.toString(w)).
																							drawTraectory(true);
	}
	
	public static void hCounter(double h) {
		
		Frame frame = new Frame();
		
		Calculator c = new Calculator();
		
		c.fieldsList.getFields().add(new Anisotrophia(0, 0));
		c.fieldsList.getFields().add(new Circular(0, 0));
		ArrayList<Double> energyList = new ArrayList<Double>();
		double tetta;
		double anglestep = 0.05;
		
		for (double w = 0.01; w <= 2.0001; w += 0.01) {//TODO
			
			frame.printText(new Date().toString(), false);
			frame.printText("h : " + h, false);
			frame.printText("w : " + w, true);
			
			((Circular) c.fieldsList.get(Circular.class)).setNewData(w, h);
			double energy = 0;
			for (double i = 0; i <= 1; i += anglestep) {
				tetta = Math.acos(2 * i - 1);
				((Anisotrophia) c.fieldsList.get(Anisotrophia.class)).setVector(new Vector(tetta, 0));
				c.run(500);
				energy += c.getObserverValue(EnergyCounter.class);
			}
			energyList.add(energy * anglestep);
			Writer.writeDoubleList(energyList, "(sigma = " + c.sigma +"), h = " + h);
		}
		frame.dispose();
	}
	
	private static Impuls updateImpuls(Impuls impuls, double h, double tao) {
		impuls.list.clear();
		impuls.add(0, h, 0.01);
		impuls.add(h, h, tao - 0.02);
		impuls.add(h, 0, 0.01);
		return impuls;
	}
		
	public static void diagramm() {
		Calculator c = new Calculator();
		c.fieldsList.getFields().add(new Anisotrophia(0, 0));
		Impuls impuls = new Impuls(new Vector(1, 0, 0));
		c.fieldsList.getFields().add(impuls);
		
		LinkedList<Double> taoList = new LinkedList<Double>();
		LinkedList<Double> hList = new LinkedList<Double>();
		
		int counter = 0;
		
		for (double h = 0.01; h <= 1; h += 0.01) {
			System.out.println("h = " + h + " / " + new Date());
			for (double tao = 0; tao <= 20; tao += 0.01) {
				updateImpuls(impuls, h, tao);
				c.run(0, tao + 1);
				if (c.getArray().getLast().getZ() < 0) {
					taoList.add(tao);
					hList.add(h);
				}
			}
			if (counter++%10==0) {
				Writer.writeDoubleList(taoList, "Tao list " + h);
				Writer.writeDoubleList(hList, "h list" + h);
			}
		}
		Writer.writeDoubleList(taoList, "Tao list ");
		Writer.writeDoubleList(hList, "h list");
	}
	
	public static void longCalculation() {
		
		Frame frame = new Frame();
		
		Calculator c = new Calculator();
		c.fieldsList.getFields().add(new Anisotrophia(0, 0));
		c.fieldsList.getFields().add(new Circular(0, 0));
		
		double tetta;
		double anglestep = 0.05;
		
		for (double h = 0.15; h <= 0.5; h += 0.05) {

			ArrayList<Double> energyList = new ArrayList<Double>();
			for (double w = 0.01; w <= 2.0001; w += 0.01) {//TODO
				
				frame.printText(new Date().toString(), false);
				frame.printText("h : " + h, false);
				frame.printText("w : " + w, true);
				
				((Circular) c.fieldsList.get(Circular.class)).setNewData(w, h);
				//frame.notify("W: " + w);	///TODO
				double energy = 0;
				for (double i = 0; i <= 1; i += anglestep) {
					
					tetta = Math.acos(2 * i - 1);
					((Anisotrophia) c.fieldsList.get(Anisotrophia.class)).setVector(new Vector(tetta, 0));
					c.run(800, 100);
					energy += c.getObserverValue(EnergyCounter.class);
				}
				energyList.add(energy * anglestep);
				Writer.writeDoubleList(energyList, "(sigma = " + c.sigma +"), h = " + h);
			}
		}
		frame.dispose();
	}
	
}